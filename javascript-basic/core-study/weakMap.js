/**
 * WeakMap
 * 자바스크립트 엔진은 도달가능한 (추후 사용될 가능성이 있는) 값을 메모리에 유지한다.
 * 자료구조를 구성하는 요소도 자신이 속한 자료구조가 메모리에 남아있는 동안, 대개 도달가능한 값으로 취급되어 메모리에서 삭제되지 않는다.
 * 객체의 프포퍼티나 배열의 요소, 맵이나 셋을 구성하는 요소들이 이에 해당한다.
 */
var a = {name : "a"}; // 이 객체는 a라는 참조를 통해 접근할 수 있다.
a = null; // 그런데 참조를 null 로 덮어 쓰면 위 객체는 더이상 도달이 가능하지 않게되어, 객체가 메모리에서 삭제된다.

var a = {name : "a"};
var arr = [a];
a = null; // 참조를 null로 덮어씀, a를 나타내는 객체는 배열의 요소이기 때문에 가비지 컬렉터의 대상이 되지 않는다. 맵에서 객체를 키로 사용한 경우 역시, 맵이 메모리에 있는한 객체도 메모리에 남는다.

var a = {name : "a"};
var map = new Map();
map.set(a, "test");
a = null;
for(let key of map.keys()){
    console.log(key);
}

var a = {name : "a"};
var weakMap = new WeakMap();
weakMap.set(a, "test");
a = null; // 참조를 덮어쓰게 되면 이 객체는 weakMap 과 memory에서 자동 삭제된다.

// map 과 weakMap 의 두번째 차이는 반복작업과 keys(), values(), entries() 메소드를 지원하지 않는다는 점이다. 따라서 weakMap에선 키나 값 전체를 얻는 것이 불가능하다.
/**
 * get
 * set
 * delete
 * has
 * 등의 메소드만 제공한다.
 * 원인은 가비지 컬렉션의 동작 방식 때문이다.
 */

/**
 * weakMap 은 어떤 경우에??
 * 추가 데이터 - 가비지 컬렉션 대상이 필연적으로 되어야할 경우에 좋다.
 * 캐싱 - 동일한 함수를 여러번 호출해야할 때, 최초 호출 시 반환된 값을 어딘가에 저장해 놓았다가
 * 그 다음엔 함수를 호출하는 대신, 저장된 값을 사용 캐시를 다 사용하고 나면 메모리 해체에 유리하기 때문에 좋다.
 */